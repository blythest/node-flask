// Generated by CoffeeScript 1.3.3
(function() {
  var Compiler, RegexExtractor, Router, RuleExtractor, absoluteUrl, defaultParser, escapeRegex, normalizePathname, url,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  url = require('url');

  escapeRegex = function(s) {
    return s.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
  };

  absoluteUrl = function(req, pathname, search) {
    var port, protocol, rv;
    protocol = 'http';
    if (req.headers['x-protocol'] === 'https') {
      protocol = 'https';
    }
    rv = [protocol, '://', req.headers.host];
    if (port = req.headers['x-port']) {
      rv.push(":" + port);
    }
    rv.push(pathname);
    if (search) {
      rv.push(search);
    }
    return rv.join('');
  };

  normalizePathname = function(pathname) {
    var match, rv;
    rv = pathname.replace(/\/\.\//g, '/');
    while (match = /\/[^/][^/]*\/\.\./.exec(rv)) {
      rv = rv.replace(match[0], '');
    }
    rv = rv.replace(/\/\.\./g, '');
    rv = rv.replace(/\.\//g, '');
    return rv || '/';
  };

  defaultParser = function(str, opts) {
    if (typeof str !== 'string' || !str.trim() || str.indexOf('/') !== -1) {
      return null;
    }
    return str;
  };

  RegexExtractor = (function() {

    function RegexExtractor(regex) {
      this.regex = regex;
    }

    RegexExtractor.prototype.extract = function(requestPath) {
      var m;
      m = this.regex.exec(requestPath);
      if (!m) {
        return null;
      }
      return m.slice(1);
    };

    RegexExtractor.prototype.test = function(requestPath) {
      return this.extract(requestPath) !== null;
    };

    return RegexExtractor;

  })();

  RuleExtractor = (function(_super) {

    __extends(RuleExtractor, _super);

    function RuleExtractor(parsers) {
      this.parsers = parsers;
      this.regexParts = ['^'];
      this.params = [];
    }

    RuleExtractor.prototype.pushStatic = function(staticPart) {
      return this.regexParts.push(escapeRegex(staticPart));
    };

    RuleExtractor.prototype.pushParam = function(dynamicPart) {
      this.params.push(dynamicPart);
      return this.regexParts.push('(.*?)');
    };

    RuleExtractor.prototype.compile = function() {
      this.regexParts.push('$');
      this.regex = new RegExp(this.regexParts.join(''));
      return this;
    };

    RuleExtractor.prototype.extract = function(requestPath) {
      var extractedArgs, i, m, param, params, parser, parsers, value, _i, _ref;
      m = this.regex.exec(requestPath);
      if (!m) {
        return null;
      }
      params = this.params;
      parsers = this.parsers;
      extractedArgs = [];
      for (i = _i = 1, _ref = m.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        param = params[i - 1];
        parser = parsers[param.parserName];
        if (typeof parser !== 'function') {
          parser = defaultParser;
        }
        value = parser(m[i], param.parserOpts);
        if (value === null) {
          return null;
        }
        extractedArgs[i - 1] = extractedArgs[param.name] = value;
      }
      return extractedArgs;
    };

    return RuleExtractor;

  })(RegexExtractor);

  Compiler = (function() {

    function Compiler(parsers) {
      var k, v;
      this.parsers = {
        int: function(str, opts) {
          var base, pattern, rv;
          if (typeof str !== 'string' || str.trim() === '') {
            return null;
          }
          base = 10;
          pattern = /^[0-9]+$/;
          if ((opts != null ? opts.base : void 0) === 2) {
            base = 2;
            pattern = /^[0-1]+$/;
          }
          if ((opts != null ? opts.base : void 0) === 8) {
            base = 8;
            pattern = /^[0-7]+$/;
          } else if ((opts != null ? opts.base : void 0) === 16) {
            base = 16;
            pattern = /^[0-9a-fA-F]+$/;
          }
          if (!pattern.test(str)) {
            return null;
          }
          rv = parseInt(str, base);
          if (opts) {
            if ((isFinite(opts.min) && rv < opts.min) || (isFinite(opts.max) && rv > opts.max)) {
              return null;
            }
          }
          return rv;
        },
        float: function(str, opts) {
          var rv;
          if (typeof str !== 'string' || str.trim() === '' || isNaN(str)) {
            return null;
          }
          rv = parseFloat(str);
          if (opts) {
            if ((isFinite(opts.min) && rv < opts.min) || (isFinite(opts.max) && rv > opts.max)) {
              return null;
            }
          }
          return rv;
        },
        str: function(str, opts) {
          if (defaultParser(str) === null) {
            return null;
          }
          if (opts) {
            if ((isFinite(opts.len) && str.length !== opts.len) || (isFinite(opts.min) && str.length < opts.min) || (isFinite(opts.max) && str.length > opts.max)) {
              return null;
            }
          }
          return str;
        },
        path: function(str, opts) {
          if (str || opts.optional) {
            return str;
          }
          return null;
        },
        "in": function(str, opts) {
          var args, i, _i, _ref;
          args = opts['*args'];
          for (i = _i = 0, _ref = args.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            if (args[i].toString() === str) {
              break;
            }
          }
          if (i < args.length) {
            return args[i];
          }
          return null;
        },
        uuid: function(str) {
          if (/^[0-9a-f]{8}(?:-[0-9a-f]{4}){3}-[0-9a-f]{12}$/i.test(str)) {
            return str.toLowerCase();
          }
          return null;
        }
      };
      if (parsers) {
        for (k in parsers) {
          if (!__hasProp.call(parsers, k)) continue;
          v = parsers[k];
          this.parsers[k] = v;
        }
      }
    }

    Compiler.prototype.ruleRe = /([^<]+)|(?:<(?:([a-zA-Z_][a-zA-Z0-9_]*)(?:\((.+)\))?:)?([a-zA-Z_][a-zA-Z0-9_]*)>)/g;

    Compiler.prototype.parserOptRe = /(?:([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*)?(?:(true|false)|(\d+\.\d+|\d+\.|\d+)|(\w+))\s*,?/g;

    Compiler.prototype.parseOpts = function(rawOpts) {
      var match, name, rv, value;
      rv = {
        '*args': []
      };
      while (match = this.parserOptRe.exec(rawOpts)) {
        name = null;
        if (match[1]) {
          name = match[1];
        }
        if (match[2]) {
          value = Boolean(match[2]);
        } else if (match[3]) {
          value = parseFloat(match[3]);
        } else {
          value = match[4];
        }
        if (name) {
          rv[name] = value;
        } else {
          rv['*args'].push(value);
        }
      }
      return rv;
    };

    Compiler.prototype.compile = function(pattern) {
      var extractor, match, ruleParam;
      if (pattern instanceof RegExp) {
        return new RegexExtractor(pattern);
      }
      extractor = new RuleExtractor(this.parsers);
      while (match = this.ruleRe.exec(pattern)) {
        if (match[1]) {
          extractor.pushStatic(match[1]);
        } else {
          ruleParam = {};
          if (match[2]) {
            ruleParam.parserName = match[2];
            if (match[3]) {
              ruleParam.parserOpts = this.parseOpts(match[3]);
            }
          }
          ruleParam.name = match[4];
          extractor.pushParam(ruleParam);
        }
      }
      return extractor.compile();
    };

    return Compiler;

  })();

  Router = (function() {

    function Router(compiler) {
      this.compiler = compiler;
      this.rules = {
        GET: [],
        POST: [],
        PUT: [],
        DELETE: [],
        PATCH: []
      };
      this.compiled = false;
    }

    Router.prototype.route = function(req, res, next) {
      var checkRule, fail, matchedRules, p, ruleArray, urlObj,
        _this = this;
      if (typeof next !== 'function') {
        next = function(err) {
          var status;
          status = 404;
          if (err != null ? err.status : void 0) {
            status = err.status;
          }
          res.writeHead(status);
          return res.end();
        };
      }
      urlObj = url.parse(req.url);
      p = normalizePathname(urlObj.pathname);
      req.path = p;
      this.compileRules();
      ruleArray = this.rules[req.method];
      matchedRules = {};
      checkRule = function(idx) {
        var end, extracted, handle, handlerChain, rule, status;
        if (idx === ruleArray.length) {
          return process.nextTick(fail);
        }
        rule = ruleArray[idx];
        if (extracted = rule.extractor.extract(p)) {
          matchedRules[rule.id] = 1;
          req.params = extracted;
          end = res.end;
          status = {
            done: false
          };
          res.end = function() {
            status.done = true;
            return end.call(res);
          };
          handlerChain = rule.handlers;
          handle = function(i) {
            var current, n;
            n = function(arg) {
              if (status.done) {
                return;
              }
              if (arg === 'route') {
                return process.nextTick(function() {
                  return checkRule(idx + 1);
                });
              }
              if (i === handlerChain.length - 1) {
                return res.end();
              } else {
                return process.nextTick(function() {
                  return handle(i + 1);
                });
              }
            };
            current = handlerChain[i];
            return current(req, res, n);
          };
          return handle(0);
        } else {
          return process.nextTick(function() {
            return checkRule(idx + 1);
          });
        }
      };
      fail = function() {
        var allowed, bp, extracted, method, rule, _i, _j, _len, _len1, _ref;
        bp = p + '/';
        for (_i = 0, _len = ruleArray.length; _i < _len; _i++) {
          rule = ruleArray[_i];
          if (extracted = rule.extractor.extract(bp)) {
            if (rule.id in matchedRules) {
              continue;
            }
            res.writeHead(301, {
              'Location': absoluteUrl(req, bp, urlObj.search)
            });
            res.end();
            return;
          }
        }
        allowed = [];
        _ref = _this.rules;
        for (method in _ref) {
          if (!__hasProp.call(_ref, method)) continue;
          ruleArray = _ref[method];
          if (method === req.method) {
            continue;
          }
          for (_j = 0, _len1 = ruleArray.length; _j < _len1; _j++) {
            rule = ruleArray[_j];
            if (rule.extractor.test(p)) {
              if (rule.id in matchedRules) {
                continue;
              }
              allowed.push(method);
              break;
            }
          }
        }
        if (allowed.length) {
          res.writeHead(405, {
            'Allow': allowed.join(', ')
          });
          res.end();
          return;
        }
        return next();
      };
      return checkRule(0);
    };

    Router.prototype.register = function() {
      var handler, handlerArray, handlers, id, methodName, pattern, prefix, rule, ruleArray, _i, _j, _len, _len1;
      prefix = arguments[0], methodName = arguments[1], pattern = arguments[2], handlers = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
      ruleArray = this.rules[methodName];
      if (this.compiled) {
        throw new Error('Cannot register rules after compilation');
      }
      if (!(typeof pattern === 'string' || pattern instanceof RegExp)) {
        throw new Error('Pattern must be rule string or regex');
      }
      id = "" + prefix + "#" + (pattern.toString());
      handlerArray = null;
      for (_i = 0, _len = ruleArray.length; _i < _len; _i++) {
        rule = ruleArray[_i];
        if (rule.id === id) {
          handlerArray = rule.handlers;
          break;
        }
      }
      if (!handlerArray) {
        handlerArray = [];
        ruleArray.push({
          id: id,
          pattern: pattern,
          handlers: handlerArray
        });
      }
      for (_j = 0, _len1 = handlers.length; _j < _len1; _j++) {
        handler = handlers[_j];
        if (typeof handler === 'function') {
          handlerArray.push(handler);
        } else if (Array.isArray(handler)) {
          this.register.apply(this, [prefix, methodName, pattern].concat(handler));
        } else {
          throw new Error('Handler must be a function or array of functions');
        }
      }
      return handlers;
    };

    Router.prototype.compileRules = function() {
      var compiled, method, rule, ruleArray, _i, _len, _ref;
      if (this.compiled) {
        return;
      }
      _ref = this.rules;
      for (method in _ref) {
        if (!__hasProp.call(_ref, method)) continue;
        ruleArray = _ref[method];
        for (_i = 0, _len = ruleArray.length; _i < _len; _i++) {
          rule = ruleArray[_i];
          rule.extractor = this.compiler.compile(rule.pattern);
        }
      }
      return compiled = true;
    };

    return Router;

  })();

  module.exports = function(parsers) {
    var compiler, r;
    if (!compiler) {
      compiler = new Compiler(parsers);
    }
    r = new Router(compiler);
    return {
      route: function(req, res, next) {
        return r.route(req, res, next);
      },
      registerParser: function(name, parser) {
        return compiler.parsers[name] = parser;
      },
      get: function() {
        var handlers, pattern;
        pattern = arguments[0], handlers = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        return r.register.apply(r, ['get', 'GET', pattern].concat(__slice.call(handlers)));
      },
      post: function() {
        var handlers, pattern;
        pattern = arguments[0], handlers = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        return r.register.apply(r, ['post', 'POST', pattern].concat(__slice.call(handlers)));
      },
      put: function() {
        var handlers, pattern;
        pattern = arguments[0], handlers = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        return r.register.apply(r, ['put', 'PUT', pattern].concat(__slice.call(handlers)));
      },
      del: function() {
        var handlers, pattern;
        pattern = arguments[0], handlers = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        return r.register.apply(r, ['del', 'DELETE', pattern].concat(__slice.call(handlers)));
      },
      patch: function() {
        var handlers, pattern;
        pattern = arguments[0], handlers = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        return r.register.apply(r, ['patch', 'PATCH', pattern].concat(__slice.call(handlers)));
      },
      all: function() {
        var handlers, method, pattern, _i, _len, _ref;
        pattern = arguments[0], handlers = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        _ref = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          method = _ref[_i];
          r.register.apply(r, ['all', method, pattern].concat(__slice.call(handlers)));
        }
        return handlers;
      }
    };
  };

}).call(this);
